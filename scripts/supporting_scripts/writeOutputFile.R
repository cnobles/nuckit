#' Write output files based on file extensions.
#' @param object any object that can be coerced to a data.frame with 
#' as.data.frame() methods. Can also be a list of objects with the same 
#' requirements. In the latter case, the file name will be parsed into a prefix
#' and file extension, and the name of the object will be inserted between them
#' when writen to either a csv or tsv file.
#' @param file character File name with extension. Supported formats include:
#' csv, tsv, rds, and RData.
#' @param format character selects format and accepts: "any", "csv", "tsv", 
#' "rds", "RData". The "any" option will try to match the right format given the
#' file extension. 
#' @author Christopher Nobles, Ph.D.

writeOutputFile <- function(object, file, format = "any"){
  
  if( format == "any" ){
    file_type <- stringr::str_extract(file, "[\\w]+$")
  }else{
    file_type <- format
  }
  
  object_class <- class(object)
  
  if(file_type == "csv" & object_class != "list"){
    
    write.csv(
      x = as.data.frame(object, row.names = NULL), 
      file = file, 
      quote = FALSE, 
      row.names = FALSE
    )
    
  }else if(file_type == "tsv" & object_class != "list"){
    
    write.table(
      x = as.data.frame(object, row.names = NULL), 
      file = file, 
      sep = "\t",
      quote = FALSE, 
      row.names = FALSE
    )
    
  }else if(file_type == "csv" & object_class == "list"){
    
    prefix <- gsub("csv$", "", file)
    
    if( is.null(names(object)) ) names(object) <- seq_along(object)
    
    object_names <- names(object)
    file_names <- paste0(prefix, object_names, ".csv")
    
    null <- mapply(
      function(ob, file_name){
        
        ob <- as.data.frame(ob, row.names = NULL)
        write.csv(
          x = ob, 
          file = file_name, 
          quote = FALSE, 
          row.names = FALSE
        )
        
      }, 
      ob = object, 
      file_name = file_names
    )
    
  }else if(file_type == "tsv" & object_class == "list"){
    
    prefix <- gsub("tsv$", "", file)
    
    if( is.null(names(object)) ) names(object) <- seq_along(object)
    
    object_names <- names(object)
    file_names <- paste0(prefix, object_names, ".tsv")
    
    null <- mapply(
      function(ob, file_name){
        
        ob <- as.data.frame(ob, row.names = NULL)
        write.table(
          x = ob, 
          file = file_name, 
          sep = "\t", 
          quote = FALSE, 
          row.names = FALSE
        )
        
      }, 
      ob = object, 
      file_name = file_names
    )
    
  }else if(file_type == "rds"){
    
    saveRDS(object, file)
    
  }else if(file_type == "RData"){
    
    save(object, file)
    
  }else{
    
    stop("Unsupported file type. Supported: csv, tsv, rds, and RData.")
    
  }
}

#' Write empty files for requested files when coupling returns 0 alignments.
#' @description Several steps can during the coupling process may return 0 
#' results. When this happens, this function will write out empty files for 
#' those requested at the commandline. For this, the function takes 'args' as
#' its first and only argument.
#' @param args arguments generated by the commandline and argparse.
#' @author Christopher Nobles, Ph.D.

writeNullOutput <- function(args){
  if(!exists("uniq_sites")){
    metaCols <- read.table(
      text = "", 
      col.names = c("lociPairKey", "readPairKey", "sampleName", "ID"),
      colClasses = c("character", "character", "character", "character"))
    g <- GRanges()
    mcols(g) <- metaCols
    writeOutputFile(object = g, file = args$uniqOutput)}
  if(!exists("cond_sites") & !is.null(args$condSites)){
    writeOutputFile(object = GRanges(), file = args$condSites)}
  if(!exists("chimeraData") & !is.null(args$chimeras)){
    writeOutputFile(
      object = list("read_info" = data.frame(), "alignments" = GRangesList()), 
      file = args$chimeras,
      format = "rds")}
  if(!exists("multihitData") & !is.null(args$multihits)){
    writeOutputFile(
      object = list("unclustered_multihits" = GRanges(), 
                    "clustered_multihit_positions" = GRangesList(), 
                    "clustered_multihit_lengths" = list()),
      file = args$multihits,
      format = "rds")
  }
  if(args$stat != FALSE){
    if(exists("stat")){
      write.table(
        stat, file = args$stat,
        sep = ",", row.names = FALSE, col.names = FALSE, quote = FALSE)
    }else{
      write.table(
        data.frame(), file = args$stat,
        sep = ",", row.names = FALSE, col.names = FALSE, quote = FALSE)
    }
  }
}
